set nocompatible                " This must be first, because it changes other options as a side effect
filetype off
syntax on
filetype plugin indent on

call plug#begin('~/.vim/plugged')
Plug 'flazz/vim-colorschemes'
Plug 'mileszs/ack.vim'                    " Ag vim wrapper
Plug 'junegunn/fzf.vim'                   " Fzf vim wrapper
Plug 'w0rp/ale'                           " Linting
Plug 'itchyny/lightline.vim'
"Plug 'neoclide/coc.nvim', {'branch':'release'}
" Initialize plugin system
call plug#end()

" Python paths
"let g:python_host_prog = '/usr/local/bin/python3'
"let g:python3_host_prog = '/usr/local/bin/python3'

" If using tmux and iTerm2 on OSX, the following changes the cursor from a block to a cursor
" {{{
if exists('$TMUX')
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif
" }}}
set tabstop=2                   " Show existing tab with 2 spaces
set shiftwidth=2      		      " When indenting with '>' use 2 spaces
set softtabstop=2               " number of spaces in tab when editing
set expandtab                   " On pressing tab insert 2 spaces
set updatetime=300              " You will have bad experience for diagnostic messages when it's default 4000.
set viewoptions=folds,options,cursor,unix,slash
set autoindent                  " set auto-indenting on for programming
set autoread                    " auto reload files in the buffer
set noswapfile                  " get rid of swap
set showmatch                   " automatically show matching brackets
set showcmd                     " show command in bottom bar
set cursorline                  " highlight current line
set ruler                       " show the cursor position all the time
set mouse=a                     " Enable mouse usage
set ttymouse=xterm2             " mouse codes from iTem that Vim will recognize
set guioptions+=a               " autoselect in gui mode
set backspace=indent,eol,start  " make that backspace key work the way it should
set showmode                    " show the current mode
set number                      " show line numbers
set history=1000                " store lots of :cmdline history
set hlsearch                    " highlight matches
set incsearch                   " search as characters are entered
set ignorecase                  " ignore case while searching
set smartcase                   " combined with 'ignorecase' search is only case sensitive when an upprercase letter is used
set wildmenu                    " visual autocomplete for command menu
set splitbelow                  " new horizontal split pane to the bottom
set splitright                  " new vertical split pane to the right
set t_Co=256                    " tell the term has 256 colors
set background=light            " Use colours that work well on a dark background (Console is usually black)
set timeoutlen=1000 ttimeoutlen=0 " Eliminate ESC delay - timeoutlen is used for mapping delays, and ttimeoutlen is used for key code delays
set laststatus=2                 " Show status line
"set paste                       " ***BREAKING TABS*** Turn off autoindent when pasting

" Leader is now space, using that for shortcuts
let mapleader = " "

" Use clipboard register for everything except  delete "
set clipboard=unnamed

" FINDING FILES
" Search down into subfolders
" Provides tab-completion for all file-related tasks
set path+=**
set wildmenu " Display all matching files when we tab complete

" Fzf fuzzy finders
set rtp+=/usr/local/opt/fzf " Enable fzf

""""""""""""""
" ************
" Mappings
" ************
""""""""""""""
" Open lines, but stay in normal mode
nmap <S-CR> O<Esc>
nmap <CR> o<Esc>
nmap <Leader>f :GFiles<CR>
nmap <Leader>F :Files<CR>
nmap <Leader>t :BTags<CR>
" nmap <Leader>T :Tags<CR>
" nmap <Leader>m :Methods<CR>
nmap <Leader>b :Buffers<CR>
nmap <Leader>l :BLines<CR>
nmap <Leader>L :Lines<CR>
nmap <Leader>h :History<CR>
" nmap <Leader>H :GHistory<CR>
nmap <Leader>: :History:<CR>
nmap <Leader>M :Maps<CR>
nmap <Leader>C :Commands<CR>
nmap <Leader>' :Marks<CR>
nmap <Leader>s :Filetypes<CR>
nmap <Leader>S :Snippets<CR>
nmap <Leader><Leader>h :Helptags!<CR>
nmap <Leader>/ :Ag<Space>

" Quit
nmap <Leader>q :q<CR>

" Write
nmap <Leader>w :w<CR>

" Write Quit
nmap <Leader>x :x<CR>

" Left mouse click enters insert mode instead of visual
" map <LeftMouse> <LeftMouse>i
vnoremap . :norm.<CR> " Enable . in visual mode
nnoremap <Leader>, :nohlsearch<CR> " turn off search highlight
noremap U <C-R> " Redo with U instead of <C-R>
" Shift-Tab shift current line left 2 spaces in insert mode
inoremap <S-Tab> <C-d>

" Use different key mappings for easy navigation between splits to save a keystroke. Instead of ctrl-w then j, just ctrl-j "
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>

""""""""""""""
" ************
" END Mappings
" ************
""""""""""""""

" ALE
let g:ale_sign_warning = '▲'
let g:ale_sign_error = '✗'
highlight link ALEWarningSign String
highlight link ALEErrorSign Title
nmap ]w :ALENextWrap<CR>
nmap [w :ALEPreviousWrap<CR>
augroup VimDiff
  autocmd!
  autocmd VimEnter,FilterWritePre * if &diff | ALEDisable | endif
augroup END

" Lightline
let g:lightline = {
\ 'colorscheme': 'PaperColor_light',
\ 'active': {
\   'left': [['mode', 'paste'], ['filename', 'modified']],
\   'right': [['line_total'], ['percent'], ['readonly', 'trailling_space', 'linter_warnings', 'linter_errors', 'linter_ok']]
\ },
\ 'component_expand': {
\   'linter_warnings': 'LightlineLinterWarnings',
\   'linter_errors': 'LightlineLinterErrors',
\   'linter_ok': 'LightlineLinterOK',
\   'trailling_space': 'StatuslineTrailingSpaceWarning',
\ },
\ 'component_type': {
\   'readonly': 'error',
\   'linter_warnings': 'warning',
\   'trailling_space': 'warning',
\   'linter_errors': 'error',
\ },
\ 'component': {
\   'line_total': '%L lines',
\ },
\ }

colors PaperColor

function! LightlineLinterWarnings() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ◆', all_non_errors)
endfunction
function! LightlineLinterErrors() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ✗', all_errors)
endfunction
function! LightlineLinterOK() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '✓ ' : ''
endfunction

"return '[\s]' if trailing white space is detected
"return '' otherwise
function! StatuslineTrailingSpaceWarning()
  if !exists("b:statusline_trailing_space_warning")
    if !&modifiable
      let b:statusline_trailing_space_warning = ''
      return b:statusline_trailing_space_warning
    endif
    if search('\s\+$', 'nw') != 0
      let b:statusline_trailing_space_warning = '[\s]'
    else
      let b:statusline_trailing_space_warning = ''
    endif
  endif
 return b:statusline_trailing_space_warning
endfunction

" Update and show lightline but only if it's visible (e.g., not in Goyo)
function! s:MaybeUpdateLightline()
  if exists('#lightline')
    call lightline#update()
  end
endfunction

" Update the lightline scheme from the colorscheme. Hopefully.
function! s:UpdateLightlineColorScheme()
  let g:lightline.colorscheme = g:colors_name
  call lightline#init()
endfunction

augroup _lightline
  autocmd!
  autocmd User ALELint call s:MaybeUpdateLightline()
  autocmd ColorScheme * call s:UpdateLightlineColorScheme()
augroup END
